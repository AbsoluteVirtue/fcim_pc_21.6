#include <stdio.h>
#include <stdlib.h>
// длина массива, сохраненная как имя в программе для удобства
#define count 4
// функция сравнения для сортировки, см. ниже
int cmp (const void * a, const void * b)
{
    return *((int *)a) - *((int *)b);
}

int main(int argc, char const *argv[])
{
    // обычная переменная регулярного типа трактуется в программе как ее значение
    int x = 19;
    // поэтому выводится в терминал как число 19
    printf("%d\t", x);
    // для чтения из терминала с помощью scanf нужно передать адрес переменной
    // он получается унарным оператором &
    scanf("%d", &x);
    printf("%d\t", x);

    // указатель (тип данных, помеченный унарным оператором *) хранит ссылочный тип данных (адрес в памяти)
    // например, в него можно записать адрес уже известной переменной
    int *p = &x;
    // тогда через указатель можно изменить значение переменной x
    scanf("%d", p); // аналогично записи scanf("%d", &x);
    printf("%d\n", x);

    // массив является особым видом указателя
    // он указывает на целый блок памяти из заданного количества значений
    int a[4]; // в данном примере -- на блок из 4-х значений типа int

    // массивы удобно обрабатывать в циклах
    // это позволяет использовать один алгоритм поочередно на всех значениях массива 
    // i - относительный адрес элемента, индекс относительно начала массива
    int i = 0;
    // при работе с массивом индекс не может быть равен или больше длины массива
    while(i < count)
    {
        // так как имя массива хранит его адрес в памяти, для использования его в scanf оператор & не нужен
        scanf("%d", a + i);
        // но он нужен при использовании значения в массиве
        scanf("%d", &a[i]);
        // это же выражение, записанное в другой форме
        scanf("%d", &*(a + i));

        i = i + 1;
    }

    for (int i = 0; i < count; i = i + 1)
    {
        // a + i - адрес элемента массива, находящегося на расстоянии i от начала
        // a[i] - значение элемента массива, находящегося на расстоянии i от начала
        // *(a + i) - другая форма записи для значения элемента массива, находящегося на расстоянии i от начала
        // здесь унарный оператор * выполняет разыменование адреса, полученного в результате выражения a + i
        printf("%d:\t%p %d %d\n", i, a + i, a[i], *(a + i));
    }

    // доступ к значению первого элемента можно получить тремя способами:
    // *a - разыменованный адрес массива всегда содержит значение его первого элемента
    // *(а + 0) - та же запись с необязательным + 0
    // a[0] - та же запись, с заменой явного разыменования на оператор доступа к элементу, в такой форме 0 обязателен

    // массив можно инициализировать конкретными значениями
    // тогда размер можно не указывать явно, он будет определен автоматически
    int b[] = {19, 4, -34, 10, -1, 194, 99};

    // встроенный алгоритм сортировки
    // требует для своей работы:
    //      указатель на сортируемый блок памяти, 
    //      количество элементов в блоке,
    //      размер одного элемента в байтах,
    //      метод сравнения в виде функции
    qsort(b, 7, sizeof(*b), cmp);
    // здесь b - указатель на начало массива,
    //       7 - количество элементов массива,
    //       sizeof - функция, определяющая размер своего аргумента в байтах,
    //       cmp - функция сравнения, определение см. выше

    for (size_t i = 0; i < 7; i++)
    {
        printf("%d ", b[i]);
    }
}
